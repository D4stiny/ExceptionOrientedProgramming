from ctypes import Union, LittleEndianStructure, c_uint8, c_uint16, c_uint32, c_uint64, memmove, pointer, sizeof
import enum


# thanks to https://wiki.loliot.net/docs/lang/python/libraries/ctypes/python-ctypes-convert-bytes-structure/
def bytes_to_struct(data, struct):
    data_struct = struct()
    # memmove in python... :(
    memmove(pointer(data_struct), data, sizeof(struct))
    return data_struct


# NT-specific structs.
class UnwindInfo(LittleEndianStructure):
    _fields_ = [
            ("Version", c_uint8, 3),
            ("Flags", c_uint8, 5),
            ("SizeOfProlog", c_uint8),
            ("CountOfCodes", c_uint8),
            ("FrameRegister", c_uint8, 4),
            ("FrameOffset", c_uint8, 4),
        ]


class UnwindCode_struct(LittleEndianStructure):
    _fields_ = [
        ("CodeOffset", c_uint8),
        ("UnwindOp", c_uint8, 4),
        ("OpInfo", c_uint8, 4)
    ]


class UnwindCode(Union):
    _fields_ = [
        ("s", UnwindCode_struct),
        ("FrameOffset", c_uint16)
    ]


class ScopeRecord(LittleEndianStructure):
    _fields_ = [
        ("BeginAddress", c_uint32),
        ("EndAddress", c_uint32),
        ("HandlerAddress", c_uint32),
        ("JumpTarget", c_uint32),
    ]


class ScopeTable(LittleEndianStructure):
    _fields_ = [
        ("Count", c_uint32)
        # No scope record entries here (need to do manually) b/c it has dynamic size.
    ]


class RuntimeFunction(LittleEndianStructure):
    _fields_ = [
        ("BeginAddress", c_uint32),
        ("EndAddress", c_uint32),
        ("UnwindInfoAddress", c_uint32)
    ]


class UnwindHistoryTableEntry(LittleEndianStructure):
    _fields_ = [
        ("ImageBase", c_uint64),
        ("FunctionEntry", c_uint64)
    ]


class UnwindHistoryTable(LittleEndianStructure):
    _fields = [
        ("Count", c_uint32),
        ("LocalHint", c_uint8),
        ("GlobalHint", c_uint8),
        ("Search", c_uint8),
        ("Once", c_uint8),
        ("LowAddress", c_uint64),
        ("HighAddress", c_uint64),
        # No unwind history table entries here (need to do manually) b/c it has dynamic size.
    ]


class DispatcherContext(LittleEndianStructure):
    _fields_ = [
        ("ControlPc", c_uint64),
        ("ImageBase", c_uint64),
        ("FunctionEntry", c_uint64),
        ("EstablisherFrame", c_uint64),
        ("TargetIp", c_uint64),
        ("ContextRecord", c_uint64),
        ("LanguageHandler", c_uint64),
        ("HandlerData", c_uint64),
        ("HistoryTable", c_uint64),
        ("ScopeIndex", c_uint32),
        ("Fill0", c_uint32)
    ]


class PartialContext(LittleEndianStructure):
    # We only need the _CONTEXT struct up to Rsp.
    _fields_ = [
        ("P1Home", c_uint64),
        ("P2Home", c_uint64),
        ("P3Home", c_uint64),
        ("P4Home", c_uint64),
        ("P5Home", c_uint64),
        ("P6Home", c_uint64),
        
        ("ContextFlags", c_uint32),
        ("MxCsr", c_uint32),
        
        ("SegCs", c_uint16),
        ("SegDs", c_uint16),
        ("SegEs", c_uint16),
        ("SegFs", c_uint16),
        ("SegGs", c_uint16),
        ("SegSs", c_uint16),
        ("EFlags", c_uint32),

        ("Dr0", c_uint64),
        ("Dr1", c_uint64),
        ("Dr2", c_uint64),
        ("Dr3", c_uint64),
        ("Dr6", c_uint64),
        ("Dr7", c_uint64),
        
        ("Rax", c_uint64),
        ("Rcx", c_uint64),
        ("Rdx", c_uint64),
        ("Rbx", c_uint64),
        ("Rsp", c_uint64),
        ("Rbp", c_uint64),
        ("Rsi", c_uint64),
        ("Rdi", c_uint64),
        ("R8", c_uint64),
        ("R9", c_uint64),
        ("R10", c_uint64),
        ("R11", c_uint64),
        ("R12", c_uint64),
        ("R13", c_uint64),
        ("R14", c_uint64),
        ("R15", c_uint64),

        ("Rip", c_uint64),
    ]


# Our structs.
class PacketType(enum.Enum):
    Leak = 0
    LeakResponse = 1
    UpdateHeapData = 2
    Overflow = 3


class BasePacket(LittleEndianStructure):
    _fields_ = [
        ("Type", c_uint32),
        ("Size", c_uint32)
    ]


class LeakRequest(LittleEndianStructure):
    _fields_ = [
        ("Header", BasePacket),
        ("RequestedHeapSize", c_uint32)
    ]


class LeakResponse(LittleEndianStructure):
    _fields_ = [
        ("Header", BasePacket),
        ("NtdllBaseAddress", c_uint64),
        ("AllocatedHeapMemory", c_uint64)
    ]


# UPDATE_HEAP_REQUEST / OVERFLOW_REQUEST need to be sent manually
# as they contain dynamic byte arrays.

